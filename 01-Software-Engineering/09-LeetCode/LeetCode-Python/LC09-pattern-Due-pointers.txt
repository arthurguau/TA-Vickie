
//-- ############################################################# --//
     LeetCode practices                 
//-- ############################################################# --//



//-- ############################################################# --//
      Due pointers
       1. two sum
       2. merged sorted array
       3. sliding window
       4. slow/fast pointer
//-- ############################################################# --//


//-- ############################################################# --//
      1. Two sum - sorted list
//-- ############################################################# --//

# problem:
Given an array of integers nums and an integer target, 
return indices of the two numbers such that they add up to target.


# test data:

Example 1:

Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].
Example 2:

Input: nums = [2, 3, 4, 7, 8], target = 6
Output: [0, 2]
Example 3:


# Code snippet:

class Solution:
    
    def twoSum(numbers: list[int], target: int) -> list[int]:
        l, r = 0, len(numbers) - 1
        while l < r:
           two_sum = numbers[l] + numbers[r]
           if two_sum == target:
              break
           if two_sum < target:
              l += 1
           else:
              r -= 1
        return [l, r]


//-- ############################################################# --//
     2. merged sorted array
//-- ############################################################# --//

[toDo]


//-- ############################################################# --//
     3. Sliding window 
//-- ############################################################# --//

# reference
1004. Max Consecutive Ones III

Given a binary array nums and an integer k, return the maximum number of consecutive 1's in the array if you can flip at most k 0's.

Example 1:

Input: nums = [1,1,1,0,0,0,1,1,1,1,0], k = 2
Output: 6

Explanation: [1,1,1,0,0,1,1,1,1,1,1]
Bolded numbers were flipped from 0 to 1. The longest subarray is underlined.
Example 2:

Input: nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], k = 3
Output: 10

Explanation: [0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]
Bolded numbers were flipped from 0 to 1. The longest subarray is underlined.


# Code snippet:

class Solution:

 def longest(a) -> int:
     currWindowSize = 0
     maxWindow = 0
     startIndex, endIndex = 0, 0
     x = range(len(a))  # index
     print (x)
     
     inWindow = False  # in Window? initialized as false 
     readyCalculate = False
     for i in x :
       print (i, a[i])
         
       # set startIndex for New Window
       if a[i] == 1 and inWindow == False:              
          startIndex = i
          inWindow = True
          print ("New window start --> ", startIndex)

       # set endIndex for New Window
       if a[i] == 0 and inWindow == True: 
         endIndex = i -1 
         inWindow = False            
         print ("New window end --> ", endIndex)
         # calculate current window size  
         currWindowSize = endIndex - startIndex + 1
         # update max window size if needed   
         if maxWindow < currWindowSize:    
            maxWindow = currWindowSize
         print ("current window --> ", startIndex, endIndex, currWindowSize) 
    
     return maxWindow;


---------- to do:
    def longestOnes(self, mums: list[int], k: int) -> int:



//-- ############################################################# --//
     4. slow/fast pointer
//-- ############################################################# --//

[toDo]


//-- ############################################################# --//