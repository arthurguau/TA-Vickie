//-- ########################################################### --//
     Prerequisites:
     OpenJDK 17 installed & configured
//-- ########################################################### --//


//-- ########################################################### --//
     Object 2 methods:
     01. hashCode()
     02. equals()
//-- ########################################################### --//

# 01. hashCode()  -- define hashing algorithms
To store/retrieve its elements, a hashing method, 
accessing an object’s hashCode value to determine the bucket in which it should be stored.

# 02. equals()    -- gets called to define if two equal
2 objects in the same bucket first, then equal


//-- ########################################################### --//
     Generic Types
//-- ########################################################### --//

# Concept - generic type
a generic class or interface that is parameterized over types.

/**
 * Generic version of the Box class.
 * @param <T> the type of the value being boxed
 */
public class Box<T> {

    // T stands for "Type"
    private T t;

    // assign instance variable
    public void set(T t) { this.t = t; }

    // return an object of type T
    public T get() { return t; }
}


//-- ########################################################### --//
     Compare 2 ways:
     01. comparable <T> - method
     02. comparator <T> - interface
//-- ########################################################### --//


//-- ########################################################### --//
     01. comparable <T> method
//-- =========================================================== --//

class Person implements Comparable<Person> {
   String name; 
   int age;
   Person (String name, int age) { 
     this.name = name;
     this.age = age;
 }

 public int compareTo(Person person) { 
   return (this.age-person.age); 
 }

 public String toString() { 
   return name; 
 }
}

class ComparableDemo {

   public static void main(String args[]) {
     TreeSet<Person> set = new TreeSet<>();

     set.add(new Person("Shreya", 12));
     set.add(new Person("Harry", 40));
     set.add(new Person("Paul", 30));
   
     Iterator<Person> iterator = set.iterator();
     while(iterator.hasNext()) {
        System.out.println(iterator.next());
     }
   }
}


//-- ########################################################### --//
     02. Comparator <T> - interface
//-- =========================================================== --//
[toDo]


//-- ########################################################### --//
     Data Structure:
     1. List
     2. Set
     3. Queue
     4. Map
//-- ########################################################### --//


//-- ########################################################### --//
     1. List
        01. ArrayList
        02. LinkedList
//-- ########################################################### --//

# 01. ArrayList
import java.util.ArrayList;

public class Main {

  public static void main(String[] args) {

    List <String> cars = new ArrayList<String>();
    cars.add("Volvo");
    cars.add("BMW");
    cars.add("Ford");
    cars.add("Mazda");

    System.out.println(cars);
  }
}

# 02. LinkedList
import java.util.LinkedList;

public class Main {

  public static void main(String[] args) {

    List<String> cars = new LinkedList<String>();
    cars.add("Volvo");
    cars.add("BMW");
    cars.add("Ford");
    cars.add("Mazda");

    System.out.println(cars);
  }
}


//-- ########################################################### --//
     2. Set
        01. HashSet
        02. LinkedHashSet
        03. TreeSet
//-- ########################################################### --//

//-- ########################################################### --//
     01. HashSet
         - no duplication
         - not ordered
         - To store/retrieve its elements, hashCode() and equals()
//-- =========================================================== --//

import java.util.HashSet;
import java.util.Set;

public class HashSetDemo {

  public static void main(String args[]) { 

      int count[] = {34, 22,10,60,30,22};
      Set<Integer> set = new HashSet<>();
      try {
         for(int i = 0; i < 5; i++) {
            set.add(count[i]);
         }
         System.out.println(set);
      }
      catch(Exception e) {}
   }
} 


//-- ########################################################### --//
     02. LinkedHashSet
         - maintains a double-linked list running through its entries. 
         - retrieve objects in the order of their insertion
//-- =========================================================== --//

import java.util.ArrayList;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;

public class CollectionDemo {
	
    public static void main (String [] args) {
    	
        Set<City> route = new LinkedHashSet<>();
    	route.add(new City("Seattle")); 
    	route.add(new City("Copenhagen")); 
    	route.add(new City("NewDelhi")); 
    	 
    	List<City> extendedRoute = new ArrayList<>(); 
    	extendedRoute.add(new City("Beijing"));
    	extendedRoute.add(new City("Tokyo"));
    	 
    	route.addAll(extendedRoute); 
    	 
    	Iterator<City> iter = route.iterator();
    	while (iter.hasNext())
    	   System.out.println(iter.next());     	
	}	
}

class City {
    String name;
	 
    City(String name) {
        this.name = name;
    }
	 
    public String toString() {
	return name;
    }
}

//-- ########################################################### --//
     03. TreeSet
         - stores all its unique elements 
         - stores in a sorted order
//-- =========================================================== --//

import java.util.*; 
  
class TreeSetDemo { 
  
    public static void main (String [] args) {
 	
      String[] myNames = {"Shreya", "Harry", "Paul", "Shreya", "Selvan"};
      TreeSet<String> treeSetNames = new TreeSet<String>(Arrays.asList(myNames)); 
	
      Iterator it = treeSetNames.iterator(); //.descendingIterator(); 
      while (it.hasNext())
	   System.out.println(it.next());
    }
}


//-- ########################################################### --//
     3. Queue
        01. ArrayDeque
        02. LinkedList
//-- ########################################################### --//


//-- ########################################################### --//
     01. ArrayDeque
//-- =========================================================== --//

import java.util.*;

class TestArrayDeque {

   public static void main(String... args) {

     String strArray[] = {"A1", "B2", "C3"}; 

     // turn a string array into a List
     ArrayDeque<String> arrDeque = new ArrayDeque<String>(Arrays.asList(strArray)); 

     //-- stack method
     arrDeque.push("D4"); 

     //-- queue method
     arrDeque.offer("E5"); 

     //arrDeque.push(null);   //-- can not push null

     System.out.println(arrDeque.pop()); 
     System.out.println(arrDeque.remove()); 
     
     arrDeque.add("F6"); 

     System.out.println(arrDeque.peek()); 
     System.out.println(arrDeque); #J
  }
}


//-- ########################################################### --//
     02. LinkedList
//-- =========================================================== --//

the same as above

//-- ########################################################### --//
     4. Map
        01. HashMap
        02. LinkedHashMap
        03. TreeMap
//-- ########################################################### --//


//-- ########################################################### --//
     01. HashMap
         - he keys of a HashMap aren’t ordered
//-- =========================================================== --//

import java.util.HashMap;
import java.util.Map;
public class CollectionsDemo {

   public static void main(String[] args) {

      Map<String, String> m1 = new HashMap<>(); 
      m1.put("Zara", "8");
      m1.put("Mahnaz", "31");
      m1.put("Ayan", "12");
      m1.put("Daisy", "14");

      System.out.println();
      System.out.println(" Map Elements");
      System.out.print("\t" + m1);
   }
}

//-- ########################################################### --//
     02. LinkedHashMap
         - maintains a double-linked list 
         - the elements in the order they were inserted.
//-- =========================================================== --//

import java.util.HashMap;
import java.util.Map;

public class CollectionsDemo {

   public static void main(String[] args) {

       Map<String, Integer> colorMap = new HashMap<>();
       colorMap.put("Red", 1);
       colorMap.put("Blue", 2);
       colorMap.put("Yellow", 3);
       colorMap.put("Purple", 4);
       colorMap.put("Orange", 5);

      for (Integer i : colorMap.values()) 
           System.out.print(i); 
     
       System.out.println("");
      
      Map<String, Integer> linkedColorMap = new LinkedHashMap<>();
      linkedColorMap.put("Red", 1);
      linkedColorMap.put("Blue", 2);
      linkedColorMap.put("Yellow", 3);
      linkedColorMap.put("Purple", 4);
      linkedColorMap.put("Orange", 5);

      for (Integer i : linkedColorMap.values()) 
           System.out.print(i);
   }
}


//-- ########################################################### --//
     03. TreeMap
         - sorted according to the natural ordering of its keys/a Comparator 
//-- =========================================================== --//

import java.util.Map;
import java.util.TreeMap;

public class CollectionsDemo {

   // The natural order of enum elements is the sequence in which they’re defined.
   enum IceCream {STRAWBERRY, CHOCOLATE, WALNUT};

   public static void main(String[] args) {

       Map<IceCream, String> flavorMap = new TreeMap<>(); 
       
       flavorMap.put(IceCream.WALNUT, "Walnut");
       flavorMap.put(IceCream.CHOCOLATE, "Chocolate");
       flavorMap.put(IceCream.STRAWBERRY, "Strawberry");


       for (String s : flavorMap.values())
            System.out.println(s);
   }
}


//-- ########################## End ############################ --//


